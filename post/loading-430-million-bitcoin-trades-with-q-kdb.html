<!DOCTYPE html>
<html><html><head><title>Loading 430 million bitcoin trades with q/kdb+</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-3213587-14"></script><link href="/css/style.css" rel="stylesheet"><meta charset="utf-8"><meta content="width=device-width, initial-scale=1" name="viewport"></head><body><div class="main"><ul class="nav"><li><a href="/">jjttjj.com</a></li><li><a href="/page/about.html">about</a></li></ul><div class="card"><div><h1>Loading 430 million bitcoin trades with q/kdb+</h1><time class="post-date" datetime="2019-01-26" pubdate>2019-01-26</time><p>The Bitmex bitcoin exchange generously <a href='https://www.bitmex.com/app/apiOverview#Historical-Data'>makes available</a> its historical trade and quote data. q/kdb+ is an amazing  programming environment for working with this type of data. </p><p>In this post I'll attempt to showcase the speed and power of the q language using this dataset. </p><p>This will not be an introductory tutorial, I'm mainly just looking to show off the power of q. Everything shown should be copy and pastable into a q so feel free to follow along!</p><h2>What you'll need</h2><ul><li>You'll need a decent amount of disk space. And time to download the data. Unzipped, the trade data csvs take up 34GB, and double that when they are processed into the database on disk (after which the csvs can be deleted).</li><li>You'll need a working installation of q, which you can obtain and find installation instructions for <a href='https://code.kx.com/q/tutorials/install/'>here</a></li><li>Because the data is stored in a public s3 bucket, the best way to obtain them is probably using the AWS cli tools, which you can see installation instructions for <a href='https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html'>here</a>.</li><li>You'll need to unzip the gzipped csv files. This tutorial will use <code>gzip</code> from the command line, which should be included on macOS, most linux distros, and Windows 10.</li></ul><h2>Getting the csv files</h2><p>Let's start off by making a directory to work in</p><pre><code>mkdir qbitmex &amp;&amp; cd qbitmex
</code></pre><p>The first step in working with the bitmex data is downloading the data itself using the AWS cli tools.</p><p>We can call the following command to download all the csv files for the trade data we currently need.</p><pre><code>aws --no-sign-request --region=eu-west-1 s3 sync s3://public.bitmex.com . --exclude &quot;&#42;&quot; --include &quot;data/trade/&#91;0123456789&#93;&#42;.csv.gz&quot;
</code></pre><p>This will take awhile.</p><p>Once this completes we'll need to unzip files we downloaded</p><pre><code>gzip -df data/trade/&#42;.gz
</code></pre><h2>Loading the data with q</h2><p>Next we'll need to actually load the files into kdb+.</p><p>The trade csvs should be in the <code>data/trade</code> directory</p><pre><code>filelist:` sv' dir ,' key dir:`:data/trade
</code></pre><p>First we'll make a function that can take a single csv file and parse the columns correctly:</p><pre><code>parse&#95;csv:&#40;&quot;zSSjfSgjff&quot;;enlist &quot;,&quot;&#41;0:

/we can test this out as follows:
/parse&#95;csv first filelist

</code></pre><p>Now things start to get a little tricky. If we had enough memory we could just load all the files one by one into in-memory tables, concatenate the results together into one big table, and save the result to disk, like:</p><pre><code>/will crash without absurd amounts of memory available
/`:trade&#95;table set &#40;,/&#41; parse&#95;csv each filelist
</code></pre><p>Unfortunately we don't have enough memory for this. There are a couple of useful kdb concepts that are designed for large tables like this.</p><p><strong>Splayed Tables</strong>: Tables that are stored on disk with a seperate file for each column. The table will be a directory in the filesystem with each column its own file.</p><p><strong>Partitioned Tables</strong>: Splayed tables which are further grouped by the values of a particular column. For example, it's common for tables to be partitioned by date. So in our case each trading date would have its own directory within the root directory (these dates would represent a "virtual column" in the resulting table), and each date directory would hold a directory for each table sharing this partition scheme (in our case "trade". So we could also have a future "quote" table which would share the same date virtual column on disk), and each of those directories would contain a file for each column associated with the date of the virtual column.</p><p>See <a href='https://code.kx.com/q4m3/14_Introduction_to_Kdb+/#140-overview'>Chapter 14</a> of the excellent <a href='https://code.kx.com/q4m3/'>Q for Mortals</a> book for a more thorough description of splaying an partitioning tables. </p><p>Here are some q functions that will help us create the table structure we need. </p><p><strong><code>.Q.en</code></strong>: takes a <code>dir</code> and <code>table</code> parameters and enumerates the symbol columns of a table, which is required for splaying a table. It's definitely worth fully understanding enumeration and what the <code>.Q.en</code> does behind the scenes. But in short enumeration is the process of turning columns of symbols into columns of integers behind the scenes for optimization purposes while still mostly allowing you to work with them and think of them as symbols.</p><p>For more on enumeration see <a href='https://code.kx.com/q4m3/7_Transforming_Data/#75-enumerations'>Q for Mortals</a> and <a href='https://code.kx.com/q/cookbook/splayed-tables/'>The Kdb+ Cookbook</a></p><p><strong><code>.Q.par</code></strong>: takes as arguments a root directory, a value that is being partitioned on, and a table name, and returns a full handle for the partition. For example</p><p>Now we can build up a partitioned table from our csv files:</p><p>First we'll create a quick helper function to log output, stolen from <a href='https://github.com/KxSystems/cookbook/blob/master/dataloader/loader.q#L27'>here</a></p><pre><code>out:{-1&#40;string .z.z&#41;,&quot; &quot;,x}
</code></pre><p>We'll name the directory for our db:</p><pre><code>dbdir:`:hdb
</code></pre><p>Now we will actually load the data!</p><p>For each file in filelist we'll call <code>parse&#95;csv</code> to load it into an in memory table. We take advantage of the fact that the csvs are already separated by date and get the date from the first row, then use that to set the writepath. </p><pre><code>loadfile:{
 out&quot;Reading file: &quot;,string x;
 data:`timestamp xasc parse&#95;csv x;
 out&quot;Read &quot;,&#40;string count data&#41;,&quot; rows&quot;;
 out&quot;Enumerating&quot;;
 data:.Q.en&#91;dbdir;data&#93;;
 dt:first raze select&#91;1&#93; timestamp.date from data;
 writepath:.Q.par&#91;dbdir;dt;`$&quot;trade/&quot;&#93;;
 writepath upsert data;
 }

\t loadfile each filelist
</code></pre><p>This will again take awhile (5 minutes on my laptop) to run. <code>\t</code> allows us to time the operation and will return the number of milliseconds elapsed. But once it completes we'll finally have a database of all the trade data!</p><p>Now we can "load" our partitioned table and begin querying it. Note that no data is actually pulled into memory until it's needed, kdb+ manages this efficiently behind the scenes.</p><pre><code>\l hdb
</code></pre><p>We now can work with all tables under the <code>hdb</code> root directory, which in our case is only <code>trade</code>:</p><pre><code>count trade
</code></pre><h2>Analyzing the data</h2><p>Now we can begin to query our data!</p><p>Let's get all the tradable symbols in our dataset, add the max and min of price for each symbol and sort by total size traded.</p><pre><code>`volume xdesc select volume:sum size,maxpx:max price,minpx:min price by symbol from trade
</code></pre><p>Let's turn the raw trade data into OHLCV bars on both daily and 5 minute time frames. Let's throw in VWAP for fun as well.</p><pre><code>daily: select open:first price, high:max price,low:min price,close:last price,
  volume:sum size,vwap:size wavg price
  by date from trade where symbol=`XBTUSD

fivemin: select open:first price,high:max price,low:min price,close:last price,
  volume:sum size,vwap:size wavg price
  by date, 5 xbar timestamp.minute from trade where symbol=`XBTUSD
</code></pre><h2>Conclusion</h2><p>Learning the various techniques kdb+ makes available for managing large amounts of data allows us to quickly get up and running with huge datasets. While loading up the data may take a bit of time, it's unlikely you'll be able to find any other language or database environment that can do this faster. The same is true of queries.</p><p>In future posts we will look at more advanced querying techniques.</p></div></div><div class="footer">Copyright Â© 2019 Justin Tirrell</div></div></body></html></html>